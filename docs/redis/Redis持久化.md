# Redis持久化

- 支持两种持久化方式
  - RDB方式
  - AOF方式

> 以下命令均不区分大小写

## RDB方式

- rdb方式的持久化是通过快照完成的

> 当符合一定条件时，Redis会自动将内存中的所有数据生成一份副本并保存到磁盘上，这个过程即为“快照”

### 如何触发

分以下几种情况执行：

- 根据配置规则进行自动快照

  配置文件中已经预设了3个条件：

  ```
  save 900 1
  save 300 10
  save 60 10000
  ```

  每个快照条件占一行，以 save 开头，秒数 + 被修改的键（以上），条件之间是“或”的关系

- 用户执行 save 或 bgsave 命令

  手动执行快照，区别在于save是同步执行快照，当数据过多时，会阻塞服务器，导致Redis长时间不响应（生产环境尽量避免此操作），bgsave是以后台异步的方式执行快照操作，可以用 lastsave 查看最近一次快照执行成功的时间戳。

- 执行 flashall 命令

  flashall 操作会清空数据库的所有数据，需要注意的是此时只要自动快照条件不为空，就会自动执行一次快照操作，无论自动快照条件满不满足。

- 执行复制（replication）时



### 快照原理

- 存储位置
  - dir：存储路径
  - dbfilename：文件名

- 过程
  1. 使用 Fork 函数复制一份当前进程（父进程）的副本（子进程）
  2. 父进程继续处理客户端发来的命令，子进程将内存中的数据写入硬盘
  3. 当子进程写完所有数据后会使用该临时文件替换旧的RDB文件，至此一次快照完成

> 执行 fork 时，操作系统会使用写时复制策略，既父子进程共享同一内存数据，当父进程要修改某片数据时，操作系统会复制该片数据以保证子进程不受影响，因此新的RDB文件保存的执行 fork 瞬间的内存数据。写时策略使得复制时内存占用不会增加一倍，但如果在快照过程中写入操作过多，fork前后数据差异过大，此时内存中既有新数据库也有fork时的数据，可能会导致内存用量超限。（可以在 /etc/sysctl.conf 文件中加入 vm.overcommit_memory=1 允许应用程序申请超过可用内存的空间）


## AOF方式

- AOF（append only file）默认不开启，可以通过配置文件参数启用：appendonly yes
- 开启后会将每条会更改 Redis 的命令写到硬盘的 AOF 文件中
  - 位置和 RDB 文件一致
  - 文件名通过参数修改：appendfilename appendonly.aof
